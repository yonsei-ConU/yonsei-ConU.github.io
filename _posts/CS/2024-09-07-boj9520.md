---
title: "백준 9520번: NP-hard"
excerpt: "관찰이 재밌었던 DP 문제"
categories:
    - CS
toc: true
toc_sticky: false
date: 2024-09-07
last_modified_at: 2024-09-07
---
## 문제 이해하기
평범한 TSP에 이상한 조건이 하나 달려 있습니다.  
물론 지문에도 써 있듯이 TSP는 NP-hard이고, 글을 쓰는 시점에서는 O(N<sup>2</sup>2<sup>N</sup>) 정도에 돌아가는 bitmask DP가 그나마 나은 풀이로 알려져 있습니다.  
그런데 이 문제의 제한은 1500이고, 지수에 제곱까지 붙은 시간복잡도로는 최소한 저희 생애 안에는 해결할 수 없어 보입니다.  
결국, 문제에 나온 이상한 조건을 이용해 다항 시간 풀이를 얻어내야겠네요.

## 관찰
조건을 살펴봅시다: `번호가 K인 도시를 방문하려면, K보다 작은 번호를 가진 모든 도시를 K번을 방문하기 전에 모두 방문하거나, 방문한 후에 모두 방문해야 한다.`  
3번 도시를 방문하고 싶다고 쳐요. 그러면 다른 도시들은 모르겠지만 최소한 1번과 2번은 모두 3번보다 먼저 방문하든 3번보다 나중에 방문하든 해야 합니다.  
1 -> 2 -> 3 순서, 3 -> 1 -> 2 순서는 가능하지만 2 -> 1 -> 3 순서는 불가능하겠죠.  
여기서 한 번 자세히 관찰해 봅시다. 무엇이 보이나요?  
스크롤 내리기 전에 조금만 생각해 보세요.  
.  
.  
.  
.  
.  
예 사실 저도 못찾았고요 이전에 소개한 적이 있는 방법을 한 번 더 사용해 봤습니다.  
```py
from itertools import permutations as pp

N = 4
for p in list(pp(range(N), N)):
    check = True
    for i in range(1, N - 1):
        if max(min(p[:i]), min(p[i + 1:])) < p[i]:
            check = False
            break
    if check:
        print(*p)
```
이렇게 백트래킹을 돌려 주었습니다.
N값을 바꿔 가면서 돌려 본 결과, N이 1 늘수록 가능한 경우의 수가 두 배로 늘어난다는 관찰을 우선적으로 할 수 있었습니다.
그리고 가능한 순열들을 좀 더 자세하게 훑어봤더니 가장 큰 수는 항상 맨 처음이나 맨 마지막에 등장하며, 가장 큰 수를 제외한 나머지 수들의 배열은 길이가 N-1인 모든 순열이라는 것을 알 수 있었습니다.  
**N = 3**  
0 1 2  
1 0 2  
2 0 1  
2 1 0  
**N = 4**  
0 1 2 3  
1 0 2 3  
2 0 1 3  
2 1 0 3  
3 0 1 2  
3 1 0 2  
3 2 0 1  
3 2 1 0  
N = 4인 경우 가능한 순열들 중 위에 4개를 봅시다. 3을 빼 놓고 보면 N = 3인 경우와 완전히 같지 않나요?  

## 문제 풀이
이를 바탕으로 DP 상태를 정의할 수 있습니다.  
DP[i][j] = **i번 도시부터 j번 도시까지 방문할 때 드는 시간의 최솟값**으로 정의합시다.  
이렇게 상태를 정의하고 나면 조금 특별한 성질이 생기는데, max(i, j)의 값이 항상 (현재까지 방문한 걸로 처리한 도시의 개수 - 1)이 됩니다. 위에서 도시 번호를 그냥 0-index로 매겼기 때문에 -1이 붙었을 뿐 이 -1에 별 의미는 없습니다.  
상태 전이를 봅시다.  
i - 1 번 도시까지 방문 처리된 상태에서 i번 도시의 방문을 처리하고자 한다면, i번 도시는 무조건 처음 방문하는 도시거나 마지막으로 방문하는 도시여야 한다는 것을 위 관찰을 통해 얻었습니다.  
`ㅇ`을 0번부터 i - 2번 도시까지 방문하는 어떤 순열이라고 할 때, 나올 수 있는 순서는  
- i, i - 1, ㅇ
- i, ㅇ, i - 1
- ㅇ, i - 1, i
- i - 1, ㅇ, i

이렇게 4가지입니다.  
이 4가지 상태 전이를 모두 해 주면 끝입니다.  
ㅇ이 끝에 있는 상태는 O(1)만에 전이시킬 수 있지만 ㅇ이 가운데에 있는 상태는 O(i)만큼이 걸립니다.  
i의 값을 2부터 시작해서 N - 1까지 늘릴 것이므로, 총 시간복잡도는 O(N<sup>2</sup>)이 됩니다.  

## 소스 코드
```py
import sys
input_ = sys.stdin.readline
def minput(): return map(int, input_().split())


INF = 20202020
N = int(input_())
costs = [list(minput()) for _ in range(N)]
dp = [[INF] * N for _ in range(N)]
dp[0][1] = costs[0][1]
dp[1][0] = costs[1][0]

for i in range(2, N):
    tmp = INF
    for j in range(i - 1):
        dp[i][j] = dp[i - 1][j] + costs[i][i - 1]
        tmp = min(tmp, dp[j][i - 1] + costs[i][j])
    dp[i][i - 1] = tmp

    tmp = INF
    for j in range(i - 1):
        dp[j][i] = dp[j][i - 1] + costs[i - 1][i]
        tmp = min(tmp, dp[i - 1][j] + costs[j][i])
    dp[i - 1][i] = tmp

ans = INF
for i in range(N - 1):
    ans = min(ans, dp[-1][i], dp[i][-1])

print(ans)
```

## 총평
플4 랜덤디펜스에서 나온 문제였는데, 이런 종류의 관찰이 저는 재밌더라고요!
