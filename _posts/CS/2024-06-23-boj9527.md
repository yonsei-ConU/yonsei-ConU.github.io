---
title: "백준 9527번: 1의 개수 세기"
excerpt: "머리 쓰는 문제는 좋아요"
categories:
    - CS
toc: true
toc_sticky: false
date: 2024-06-23
last_modified_at: 2024-06-23
---
## 문제 이해하기
클래스 5를 밀다가 만난 문제입니다.  
문제를 이해하는 것 자체는 매우 쉽죠.  
그냥 문제에서 하라는 대로만 하면 됩니다.

## 문제 풀이
누적 합스러운 발상을 떠올려 보도록 하죠.  
구하는 것이 `x = a부터 x = b까지 f(x)들의 합` 이기 때문에, `x = 0부터 x = t까지 f(x)들의 합`을 g(t)로 정의한다면 문제에서 구하는 것을 `g(b) - g(a-1)`로 바꾸어 구할 수 있게 됩니다.  
그리고 문제 입력으로 주어지는 수가 자연수이기 때문에 g(a-1)을 구한다고 해도 a-1이 음수는 나오지 않습니다. (g(0) = 0이므로 0일 때는 신경쓰지 않아도 됩니다)  
이제 문제의 요구사항을 조금 더 쉽게 바꿨습니다. 그러면 g(t)의 값은 어떻게 구해야 할까요?  
g(t)는 말했지만 f(x)들의 합이므로 우선 f(x)의 값들을 작은 x에 대해서 구해 봅시다.
f(1) = 1, f(2) = 1, f(3) = 2, f(4) = 1, f(5) = 2, f(6) = 2, f(7) = 3, f(8) = 1, ...  
뭐 어떻게 하면 구할 수 있을 것 같기는 한데, 어차피 제한이 10의 16제곱이라 이것들을 전처리를 하든 어떻게 해서 구하고 난 다음에 문제를 푸는 건 불가능해 보입니다.  
그러면 g(t)의 값을 한 번에 구해야 한다는 뜻이 되겠죠.  
1부터 7까지를 이진수로 표현하면 각각 1, 10, 11, 100, 101, 110, 111이 되죠.  
여기서 등장하는 1의 개수들을 그냥 세기에는 무리가 있어 보이니, 각 비트별로 쪼개봅시다. 사실상 이 발상이 제 풀이에서는 가장 핵심적인 발상인 것 같아요.  
그러면 수열 {0, 1, 0, 1, 0, 1, 0, 1, ...}의 t번째 항까지 합과, 수열 {0, 0, 1, 1, 0, 0, 1, 1, ...}의 t번째 항까지의 합과, 수열 {0, 0, 0, 0, 1, 1, 1, 1, ...}의 t번째 항까지의 합과...... 이것들을 다 더하면 원하는 g(t)의 값이 나오겠죠. (여기서 수열의 인덱스는 0부터 시작한다고 합시다)  
아까보다는 간단해 보이는 식이 나왔고 제한이 10의 16제곱이라고 해도 비트 수는 많지 않기 때문에 이걸 빠르게 구할 수만 있다면 시간 안에 돌아가는 건 무리가 없어 보입니다. 이제 이걸 어떻게 하면 구할 수 있을까요?  
잘 이해하기 위해 예시를 하나 들어 보겠습니다. 45를 이진수로 표현하면 101101입니다.  
우선 가장 아래 비트에 등장하는 1의 개수부터 구해 봅시다. 이건 매우 간단하게 23개라는 것을 알 수 있습니다.  
하지만 그냥 23개라는 데에서 끝내지 말고 어떻게 23개가 나왔는지를 조금 더 살펴봅시다.  
일단 {0, 1} 묶음이 22묶음 있습니다. 당연하게도 여기서 22는 45//2로 나오는 값입니다.  
그 직후에 나오는 0은 44번째 항, 그 다음 1은 45번째 항이므로 1을 추가로 더해줍니다. 그러면 23이 나오죠.  
다음 비트를 봅시다.  
여기에서는 {0, 0, 1, 1} 묶음이 11묶음 있고, 그 직후에 나오는 44, 45번째 항이 모두 0입니다.  
이 과정을 계속하다 보면 일단 한 사이클로 묶을 수 있는 묶음의 개수에 대한 규칙성이 보입니다. 2의 n제곱을 담당하는 비트라고 하면 묶음은 t >> (n + 1)개 있겠죠.  
묶음은 그만큼 있지만 한 묶음당 1의 개수는 (묶음의 길이) >> 1 이므로 묶음들에서 나오는 1의 개수의 총합은 t >> (n + 1) << n이 됩니다. 이는 t >> 1과 다름에 주의하세요.  
묶음들에서 나오는 1의 개수는 구했으니 안 묶이고 남는 부분의 1의 개수를 구해야 합니다.  
어쨌든 여기서의 1의 개수는 0으로 시작하고 1로 끝나는 0, 0, 0, ..., 0, 1, ..., 1, 1, 1꼴의 수열에서 적당한 번째 항까지 끊은 뒤 그 합을 구하면 나올 것입니다.  
만약에 지금 보고 있는, 위에서 말한 `2의 n제곱을 담당하는 비트`가 0이라면 어떻게 해야 될까요?  
이 경우에는 저 수열에서 0, 0, ... 하다가 1이 있는 항에 도착하기 전에 끊어질 것이므로 합은 그냥 0입니다.  
비트가 1인 경우에는 어디까지가 잘리는지가 중요해지겠죠.  
다시 g(45)를 구하던 예시로 돌아가봅시다. 지금 할 것은 4를 담당하는 비트에서 나오는 1의 개수를 셀 것입니다.  
위에서 언급했듯이 0, 0, 0, 0, 1, 1, 1, 1이 반복되는 수열에서 45번째 항까지 구해야 하고, 40개의 항은 묶을 수 있고 묶은 항들에 있는 1의 개수 총합은 20개입니다.  
그러면 (수열의 인덱스가 0부터 시작하므로) 0, 0, 0, 0, 1, 1까지의 합을 구해야겠죠.  
여기서 한 번 더 생각해보기 위해 40부터 45까지 이진법으로 나열해 봅시다.  
101000, 101001, 101010, 101011, 101100, 101101  
45의 이진법 표현에서 4보다 작은 값을 담당하는 비트만 살펴보면 그 값은 01입니다.  
여기에다가 00인 경우 하나를 더한 2가 남는 1의 개수가 됩니다.  
47으로 예시를 한 번 더 들죠. 40부터 47까지 이진법으로 나열하면 101000, 101001, 101010, 101011, 101100, 101101, 101110, 101111이 됩니다.  
47의 이진법 표현에서 4보다 작은 값을 담당하는 비트만 살펴보면 그 값은 11, 즉 십진법으로 표현하면 3입니다.  
101101, 101110, 101111 이렇게 총 3개의 수가 4를 담당하는 비트가 켜진 수들이고, 여기에다가 또한 4를 담당하는 비트가 켜진 수에 해당하는 101100의 경우를 더하면 4죠.

## 소스 코드
```python
import sys
input_ = sys.stdin.readline
def minput(): return map(int, input_().split())


def count_one(n):
    strn = bin(n)[2:]
    ans = 0
    for i in range(1, len(strn) + 1):
        ans += n >> i << (i - 1)
        if strn[-i] == '1':
            if i == 1:
                ans += 1
            else:
                ans += 1 + int(strn[1-i:], 2)
    return ans

A, B = minput()
print(count_one(B) - count_one(A - 1))
```

## 총평
복잡한 알고리즘은 필요없지만 머리를 굴리는 게 힘든 문제였습니다. 이런 문제가 코드포스에 나오면 힘들겠지만 시간을 오래 주고 풀라고 하면 재밌는 문제 유형같아요.
