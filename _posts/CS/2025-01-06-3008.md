---
title: "백준 3008 직각 삼각형의 개수"
excerpt: "세제곱보다 빨라지려면 어떻게 해야 할까요?"
categories:
    - CS
toc: true
toc_sticky: false
date: 2025-01-06
last_modified_at: 2025-01-06
---
## 문제 이해하기
2차원 평면 위에 점 N개가 있다. 세 점을 골랐을 때, 직각 삼각형을 이루는 것의 쌍의 수를 구하는 프로그램을 작성하시오.  
간단하죠? 말 그대로 직각 삼각형의 개수를 세면 되는 문제입니다.  
우선 제한을 봅시다. 점의 개수를 의미하는 N이 최대 1500이네요.  
간단한 O(N<sup>3</sup>) 브루트 포스는 아쉽게도 통하지 않을 것입니다.  
세제곱 시간보다 빠르게 찾으려면 어떻게 해야 할까요?

## 문제 풀기
[9015번 정사각형](<https://www.acmicpc.net/problem/9015>) 이나 이 문제같은 종류의 문제들에서 알아두면 좋은 테크닉은, **점 몇 개를 미리 고정해놓고 생각하면 편하다**는 것입니다.  
9015번의 경우 점 두 개를 고정한 뒤 나머지 두 점이 존재하는지를 판단하면 쉽게 풀 수 있으니, 해당 문제도 도전해 보시면 좋을 것 같네요.  
3008번의 경우에서도 점 두 개를 고정해 보겠습니다.  
우리가 세어야 하는 것은 넓이가 가장 큰 직각삼각형의 넓이와 같은 것이 아닌 직각삼각형의 개수이므로, 빼먹지도 않고 같은 걸 여러 번 세지도 않아야 합니다.  
일단 두 점이 고정됐다고 생각해 보죠. 그러면 우리는 나머지 한 점으로 가능한 점의 개수를 세면 됩니다.  
그런데 여기서 나머지 한 점이라고 하면, 나올 수 있는 경우의 수가 너무 많습니다.  
고정된 두 점으로 이루어진 선분이 빗변일 수도 있고 빗변이 아닐 수도 있죠.  
하지만 모든 빗변에 대해 브루트포스한다고 생각해 보면 같은 걸 여러 번 세는 경우는 없을 것입니다.  
그래서 고정된 두 점으로 이루어진 선분이 빗변일 경우 나머지 점으로 가능한 개수를 전부 더하면 답이겠죠.  
또한 직각삼각형의 빗변은 외접원의 지름이기 때문에 빗변을 지름으로 하는 원 위의 점의 개수를 세면 됩니다.  
그런데 그게 O(1)만에 될까요?  
점 두 개를 고정한 경우를 전부 봐야 하므로 O(N<sup>2</sup>)번 반복해야 하기 때문에 이걸 세는 데 O(N)이 든다면 총 시간복잡도는 결국 세제곱이 되어 점을 고정시켜도 별 의미가 없을 것입니다.  
일단 저는 O(1)만에 저걸 셀 방법을 찾지 못했고, 그래서 점을 고정할 다른 방법을 찾았습니다.  
직각을 낀 점을 기준으로 고정해 보는 건 어떨까요?  
점을 하나만 고정한 다음에, 그 점에서 직각이 나온다고 생각하고 문제를 푸는 겁니다.  
직각삼각형에서 직각이 두 개일 수는 없으므로 같은 걸 여러 번 세는 경우는 없습니다.  
그러면 한 점이 고정됐다 치고 그 상태에서 나머지 점들은 어떻게 확정시킬 수 있을까요?  
고정한 점에서 직각이 나온다는 가정 때문에 O(N)만에 가능합니다.  
우선 고정점이 아닌 모든 점에 대해, 고정점과의 기울기를 구해줍니다.  
단, 기울기를 그냥 실수로 구하면 오차도 날 거고 0으로 나누는 문제도 발생할 거고 문제가 많습니다. 고정점에서 시작해서 고정점이 아닌 점으로 끝나는 벡터를 구한다고 생각하시는 게 더 편합니다.  
모든 점까지의 기울기를 구하고 나면 점 하나를 더 고정할 수 있습니다.  
두 점이 고정되고 나면, 이 상황에서는 두 점 A, B가 정해져 있고 각 CAB가 직각이라는 걸 알고 있는 상태에서 점 C가 될 수 있는 점의 개수를 세는 문제가 됩니다.  
이것도 그냥 세려면 O(N)이겠지만, 우리는 AB의 기울기와 AC의 기울기를 모두 알고 있기 떄문에 O(1)만에 구할 수 있게 됩니다.  
각 기울기별로 점의 개수를 위에서 미리 세어 놓으면, AB의 기울기가 주어졌을 때 그 기울기 + 90도 에 해당하는 기울기인 점의 개수를 세면 답이 됩니다.  

## 코드
```py
import sys
from math import gcd
from collections import defaultdict
input_ = sys.stdin.readline
def minput(): return map(lambda x: int(x) << 1, input_().split())


def get_incl(dy, dx):
    if dx < 0:
        dy *= -1
        dx *= -1
    if not dy:
        dx = 1
    elif not dx:
        dy = 1
    else:
        g = gcd(dx, dy)
        dy //= g
        dx //= g
    return dy, dx


N = int(input_())
points = [list(minput()) for _ in range(N)]
ans = 0

for i in range(N):
    incl = defaultdict(int)
    for j in range(N):
        if i == j:
            continue
        dy = points[j][1] - points[i][1]
        dx = points[j][0] - points[i][0]
        dy, dx = get_incl(dy, dx)
        incl[(dx, dy)] += 1
    for j in range(N):
        if i == j:
            continue
        dy = points[j][1] - points[i][1]
        dx = points[j][0] - points[i][0]
        dy, dx = get_incl(dy, dx)
        ans += incl[(-dy, dx)]

print(ans)
```

## 총평
재밌는 기하 문제였습니다.
