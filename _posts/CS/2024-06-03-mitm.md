---
title: "중간에서 만나기 (Meet in the middle) 알고리즘"
excerpt: "완전탐색을 해야 할 것 같지만 제한이 하지 말라고 할 때, 방법이 없을까요?"
categories:
    - CS
toc: false
toc_sticky: false
date: 2024-06-03
last_modified_at: 2024-06-03
---
## 개요
완전탐색을 해야 할 것 같지만 제한이 하지 말라고 할 때, 방법이 없을까요?  
이번 글에서는 예제와 함께 이런 식의 상황을 풀어나가는 방법에 대해 공부해 보도록 하겠습니다.

## 완전탐색
[백준 1182. 부분수열의 합](https://www.acmicpc.net/problem/1182)을 봅시다.  
수열이 하나 주어졌을 때 그 수열의 부분수열 중 합이 S가 되는 경우의 수를 찾는 문제입니다.  
수열의 원소들이 어떤 특별한 규칙을 만족해서 DP 등으로 깔끔하게 풀 수 있다면 모르겠지만, 그런 풀이는 보이지 않습니다.  
하지만 수열의 크기가 최대 20이므로, 단순하게 완전탐색을 돌리는 것만으로도 충분히 시간 안에 돌아가는 코드를 짤 수 있습니다.  
크기가 양수인 부분수열의 개수는 2<sup>N</sup>-1개이므로, 모든 부분수열을 돌리는 코드의 시간복잡도는 O(2<sup>N</sup>)이 됩니다.  
완전탐색을 돌리는 방법도 여러 가지가 있지만, 여기에서는 비트마스킹을 살짝 넣은 솔루션을 소개합니다.  
물론 이 문제에서는 itertools처럼 완전탐색을 하기 쉬운 다른 방법들도 있기 때문에 굳이 비트마스킹을 통한 풀이를 가져가려고 하실 필요는 없습니다.  

## 1182번 소스 코드
```python
import sys
input_= sys.stdin.readline
def minput(): return map(int, input_().split())

N, S = minput()
arr = list(minput())

ans = 0
for i in range(1, 2 ** N):
    t = 0
    for j in range(N):
        if i & (1 << j):
            t += arr[j]
    if t == S:
        ans += 1

print(ans)
```

## 브루트 포스가 불가능할 때
[백준 1208. 부분수열의 합 2](https://www.acmicpc.net/problem/1208)를 봅시다.  
문제의 이름이 알려주고 있기도 하고, 실제로 문제를 읽어 보면 거의 같은 문제임을 알 수 있습니다.  
하지만 이번에는 N의 제한이 최대 40이고, 이는 아까의 O(2<sup>N</sup>) 시간복잡도 풀이로는 풀 수 없다는 뜻입니다.  
물론 N의 제한 말고는 바뀐 점이 아무것도 없기 때문에 모든 경우를 보는 게 아닌 풀이를 찾을 수 없을 것만 같습니다.

## Meet in the middle 알고리즘
위에서 살펴본 이유로 인해 이 문제를 풀기 위해서는 더 효율적으로 부분 수열들을 살펴보는 방법이 필요한데, 이때 사용되는 것이 이 글의 주제인 **Meet in the middle 알고리즘**입니다.  
이 알고리즘은 분할 정복처럼 주어진 수열을 둘로 나눈 다음에 나누어진 수열에서 문제를 각각 풀고 합치는 방식으로 진행됩니다.  
물론 분할 정복과는 다르게 수열을 무한정 나눌 수는 없고, 한 번만 나눌 수 있습니다.  
수열을 나누는 방법은 나누어진 두 수열의 크기만 비슷하면 어떤 방법이든 상관없지만, 여기에서는 앞 N // 2 개와 뒤 나머지로 나눈다고 하겠습니다.  
우선 나눈 수열 각각에 대해 부분수열의 합들을 저장합니다. 이제는 모든 부분수열에 대해서 합을 구한다고 해도 약 2<sup>N/2</sup>번의 합만 구하면 되므로 시간제한 안에 충분히 돌아갑니다.  
이렇게 합들을 저장하고 나면 그 둘을 합치는 작업이 필요합니다.  
합들이 저장되어 있는 두 리스트에서 원소를 하나씩 뽑았을 때 그 두 원소의 합이 S가 된다면 이것은 문제의 조건을 만족하는 경우가 되겠죠.  
이 과정을 브루트 포스로 하게 된다면 두 리스트의 원소 개수의 곱만큼 연산을 해야 하는데, 두 리스트의 원소 개수가 각각 2<sup>N/2</sup> 정도이므로 총 시간복잡도는 O(2<sup>N</sup>)입니다. 기껏 수열을 둘로 나누었지만 별로 효과가 없네요.  
하지만 여기에서는 이 과정을 훨씬 더 빠르게 끝낼 수 있는 방법이 존재합니다.  
합이 들어가 있는 두 리스트 중 하나에서 뽑은 원소가 k라면, 나머지 리스트에서 S-k를 뽑아야만 그 합이 S가 되어 문제의 조건을 만족합니다.  
이분 탐색을 사용한다면, "나머지 리스트"를 정렬한 뒤 그곳에서 S-k의 개수를 세는 것은 어렵지 않은 일입니다.  
정렬과 이분 탐색을 사용한다면 총 2<sup>N/2</sup> * log(2<sup>N/2</sup>) = 2<sup>N/2</sup> * (N / 2)번 정도의 계산이 필요하고, N이 40이라고 해도 이 정도의 연산을 하는 건 충분히 가능합니다.  

## 1206번 소스 코드
```python
import sys
input_= sys.stdin.readline
def minput(): return map(int, input_().split())


N, S = minput()
arr = list(minput())
left = []
right = []
for i in range(2 ** (N//2)):
    t = 0
    for j in range(N//2):
        if i & (1 << j):
            t += arr[j]
    left.append(t)

for i in range(2 ** (N - N//2)):
    t = 0
    for j in range(N - N//2):
        if i & (1 << j):
            t += arr[j + N//2]
    right.append(t)

right.sort()
ans = 0

for i in range(len(left)):
    lo = -1
    hi = len(right)
    while lo + 1 < hi:
        mid = (lo + hi) // 2
        if left[i] + right[mid] >= S:
            hi = mid
        else:
            lo = mid
    min_idx = hi
    lo = -1
    hi = len(right)
    while lo + 1 < hi:
        mid = (lo + hi) // 2
        if left[i] + right[mid] > S:
            hi = mid
        else:
            lo = mid
    max_idx = lo
    ans += max_idx - min_idx + 1

if not S: ans -= 1
print(ans)
```
여기에서 주의해 두어야 할 것은, 앞 부분수열 또는 뒤 부분수열 중 하나에서 아무것도 고르지 않은 경우에도 문제의 정답이 될 수 있다는 점입니다. (크기가 0+1 또는 1+0인 부분수열도 `크기가 양수인 부분수열`에 해당됨)

## 정리
Meet in the middle 알고리즘은 다음과 같습니다:  
- 찾아야 하는 것 (위 문제에서는 수열)을 적당히 두 개로 나눕니다.
- 나누어진 두 부분에 대해서 각각 문제를 풉니다.
- 이분탐색을 이용해 나누어졌던 두 부분을 다시 하나로 합쳐 문제를 최종적으로 해결합니다.

이 알고리즘을 사용하면 지수 시간으로 돌아가는 완전 탐색스러운 문제들의 연산 시간을 줄여 줄 수 있게 됩니다.
