---
title: "월간 향유회 2024. 11. 후기"
excerpt: "그냥 미친 퍼포"
categories:
    - CS
toc: true
toc_sticky: false
date: 2024-11-24
last_modified_at: 2024-11-24
---
# 2411 월향
## A: No title
### 문제 요약
0이 아닌 정수 N개짜리 수열 A가 주어질 때, 인터랙터에게 두 원소의 합 또는 곱의 부호를 N번까지 질문해서 모든 N개의 수의 부호를 알아내라.  
### 체감난이도: S2~G4
### 체감 태그: 수학, 애드 혹
### 풀이
두 수의 곱이 양수면 부호가 같고, 음수면 부호가 다르다.  
이를 이용해서 N - 1 번의 질문을 통해 A1이 양수임을 가정한 상태의 모든 항 부호를 알 수 있다.  
N이 3 이상이므로 **비둘기집 원리** 에 의해 같은 부호를 가지는 두 원소가 존재한다.  
A1이 양수라고 가정하면 어떤 원소가 어떤 부호를 가지는지는 이미 알아낸 셈이므로, 같은 부호를 가지는 두 원소에 대해 두 원소의 합을 질문한다.  
그러면 해당 원소의 실제 부호를 알아낼 수 있게 되며 최종적으로 모든 원소의 부호를 질문 N번만에 알아낼 수 있게 된다.
## B: 울려퍼져라
### 문제 요약
N개짜리 자연수 수열 A가 주어지고, 매 쿼리마다 범위 [l, r]이 주어진다.  
N개짜리 수열 B는 처음에 모든 항이 0이다.  
매 쿼리마다, 모든 l <= i <= r에 대해 다음을 수행하라.  
`sum(A[l...r])개의 공 중 A[i]개의 공이 검은색일 때, 두 검은 공이 연속하는 횟수의 기댓값을 B[i]에 더한다.`  
모든 쿼리를 수행한 이후, B의 각 원소를 출력하라.  
### 체감난이도: P4~P3
### 체감 태그: 수학, 정수론, 모듈로 곱셈 역원, 자료 구조, 세그먼트 트리, 누적 합, 확률론
### 풀이
우선 구하라는 기댓값을 구해야 한다.  
구간에 검은 공이 Y개, 검지 않은 공이 X개 있다고 하자.  
어떤 위치에 검은 공이 있을 확률은 Y/(X+Y)이다.  
그럴 때 바로 오른쪽 위치에 검은 공이 있을 확률은 (Y-1)/(X+Y-1)이다.  
저 상황이 일어날 수 있는 위치는 A+B-1개이므로, 총 기댓값은 (X+Y-1) * Y / (X+Y) * (Y-1) / (X+Y-1) = Y(Y-1)/(X+Y)이다.  
이제 각 쿼리를 모든 l <= i <= r에 대해 A[i](A[i] - 1) / sum(A[l...r])을 B[i]에 더하는 쿼리로 바꿔서 생각할 수 있다.  
이때, 분자는 l, r이 어떻게 정해지든 자기 인덱스에만 영향받는다는 걸 알 수 있다.  
그래서 분자는 나중에 계산하고 1/분모 의 합만 계산해도 된다.  
이제 각 쿼리를 모든 l <= i <= r에 대해 1/sum(A[l...r])을 B[i]에 더하는 쿼리로 바꿔서 생각할 수 있다.  
물론 문제에서는 역원을 구하라고 했으므로 저거 대신 sum(A[l...r])의 역원으로 생각하면 된다.  
diff라는 새로운 리스트를 만들고 diff[l]에 1/sum(A[l...r])을 더하고 diff[r+1]에 1/sum(A[l...r])을 빼는 과정을 반복하면 O(Q)만에 모든 쿼리를 처리할 수 있고, 마지막에 합치는 과정은 diff의 누적합을 구하고 그 합과 A[i] * (A[i]-1)을 곱해야 하므로 O(N) 시간이 든다.  
## C: 연봉 998244353원 주세요
### 문제 요약
무한수열 A가 있고 A_0 = X이다.  
자연수 i에 대해, A_i는 A_(i-1)보다 크고 i의 배수인 가장 작은 자연수이다.  
10억 이하의 자연수 a를 입력받아 A[a]를 출력하는 쿼리를 Q번 수행하라.  
### 체감 난이도: ?????
### 체감 태그: 수학, 정수론
### 풀이
일단 나는 저 작업을 계속 하면 언젠가는 이웃한 두 항의 차가 일정해질 거라는 걸 이미 알고 있었다.  
그래서 앞의 항들을 나이브로 구하고 뒤의 항들은 단순 덧셈으로 구할 수 있다고 믿는다.  
언제까지 나이브로 구해야 하는지는 잘 모르기 때문에 우선 1000개 정도로 해보고 큰 입력에 대해서 차가 일정해지는지를 확인했다.  
근데 안되길래 100000개까지 나이브로 구해봤는데 되더라.  
그래서 A_10만까지는 나이브로 구하고, A_10만 - A_99999를 찾는다. 10만 이하의 입력이 들어오면 이미 구한 값을 출력하면 그만이고, 10만이 넘는 입력이 들어오면 A_100000에다가 미리 구한 차이 * (a - 100000)을 출력하면 그만이다.  
혹시 몰라 한 500만 개 나이브로 돌리는 코드를 짜놓고 스트레스를 돌렸는데 맞길래, 그대로 제출했더니 AC를 받을 수 있었다.  
# 총평
애드혹 성향이 강한 대회라고 했는데 그래도 6등이라는 좋은 성적을 기록해서 다행입니다!
